java Collections
	List
	Set

	Map		application of collection


List	is ArrayList
	unless it is specified as LinkedList

	array list has index.		contigeous

	Array vs ArrayList

	both are almost same except that Arrays cannot grow or shrink



int []arr=int[10];			//size = 10

arr[0]=55;

arr=new int[20];			//is this possible?		Yes. Here, notice that we use "new" operator.
	you are creating a new array. 

arr[0] is 0 now. NOT 55	we lost the previous array

now, tell me, can we resize an array in java??????
	We cannot resize an array.


Employee e=new Employee();
e=new Employee();



interface Person
{
	void speak();		//all that you declare inside an interface are "public"
}

class Student implements Person
{
	public void speak()		//sub class method cannot reduce the visibility
	{
		System.out.println("Student speaks");
	}
}

public class App
{
	public static void main(String []args)
	{
		Student rama=new Student();
		rama.speak();			//what will be the output of this program
	}
}

1) Student speaks
2) compilation error			
3) runtime error
4) no output


List
	ArrayList


every list supports sorting.	After adding elements, we can sort them using

Collections.sort()

Set does not allow sorting later. Only while adding elements, Set adds the element (not always at the end) but using a logic


//		ArrayList<Integer> marks=new ArrayList<>();
		List<Integer> marks=new ArrayList<>();
		marks.add(50);
		marks.add(10);
		marks.add(150);
		marks.add(510);
		marks.add(501);
		marks.add(10);
		marks.add(520);
		marks.add(350);
		marks.add(50);
		marks.add(503);
		
		System.out.println(marks);
//		Collections.sort(marks);
//		System.out.println(marks);
		
		//how can we iterate the list????????
		//2 types of iterators
		//	1) Iterator
		//	2) ListIterator		(works only for List category. Does not work for Set)
		



There are only 3 methods present in the Iterator
	hasNext()		returns true if anymore elements are available to traverse
	next()		returns the next element. It will consume and hence moves to next
	remove()		removes the current element.
			why should i use remove methods??????	

for(Integer v:marks)
		{
			if(v==10)
			{
				marks.remove(v);
			}
			System.out.println(v);
		}
the above code raise error as : 
Exception in thread "main" java.util.ConcurrentModificationException



Iterator<Integer> it = marks.iterator();
		while(it.hasNext())
		{
			Integer v = it.next();
			System.out.println(v);
		}


A ListIterator has more methods

	hasNext()
	next()
	remove()

	hasPrevious()
	previous()


Set
	DescendingIterator




1) ArrayList, LinkedList
2) HashSet
	equals		to find if two elements are duplicate or not
	hashCode		to specify the order



sort the employees by department and then by salary

excel
	
sql 
	order by dept, salary


if depts are same, then only we sort them by salary

public List<Integer> removeDuplicates(List<Integer> x)
{
	//write your code here
	//i converted this into a Set
	LinkedHashSet<Integer> temp=new LinkedHashSet<>(x);	//eliminated the duplicates. But, the order????????????????
	ArrayList<Integer> result=new ArrayList(temp);	
	return result;
}




Comparable interface is implemented by the entity class itself
	compareTo(o)
		this.getId().compareTo(o.getId());
Comparator interface is external comparator. That defines the sorting order in a separate class. 
	compare(o1,o2)
		o1.getId().compareTo(o2.getId());
	is useful when we do not have opportunity to modify the entity class. Ex: Integer (cannot be modified)

I ask you to create a TreeSet<Integer> that should maintain the elements in descending order.
i cannot implement Comparable

class IntegerComparator implements Comparator<Integer>



TreeSet<Integer> marks=new TreeSet<>(new IntegerComparator());		//use comparator to the constructor of a tree set

comparators can also be used in 
	Collections.sort	method		only for List



